export declare type None = null | undefined;
export declare type Some<T> = Exclude<T, None>;
export declare type Option<T> = Some<T> | None;
export declare function isSome<T>(option: Option<T>): option is Some<T>;
export declare function isNone<T>(option: Option<T>): option is None;
/**
 * Populate typename of `Option<T>`
 *
 * @param option
 *
 * @return Given `Option<string>`, returns `"Some(string)"` or `"None"`
 */
export declare function optionToString<T>(option: Option<T>): string;
/**
 * Match the given option
 *
 * @param option
 *
 * @return `'some' | 'none'`
 */
export declare function matchOption<T>(option: Option<T>): 'some' | 'none';
/**
 * Subtype mapper for optional value.
 *
 * @param option
 * @param map A Function to map some, or an object to map both some and none.
 *
 * @example
 * ```ts
 * let args: Option<Array<string>>;
 *
 * // Expect: Option<string>
 * const optionalArgString = mapOption(args, args => args.join(' '));
 *
 * // Expect: string
 * const argString = mapOption(args, {
 *   some: args => args.join(' '),
 *   none: '', // default value
 * });
 * ```
 */
export declare function mapOption<T, RSome, RNone = None>(option: Option<T>, map: (((t: Some<T>) => RSome) | ({
    some: RSome | ((t: Some<T>) => RSome);
    none: RNone | (() => RNone);
}))): RSome | RNone;
