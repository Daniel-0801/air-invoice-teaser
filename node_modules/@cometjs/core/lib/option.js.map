{"version":3,"sources":["../src/option.ts"],"names":["isSome","option","isNone","optionToString","matchOption","mapOption","map","Error","matchedMap"],"mappings":";;;;;;;;;;;AAEA;;AAMO,SAASA,MAAT,CAAmBC,MAAnB,EAAyD;AAC9D,SAAOA,MAAM,IAAI,IAAjB;AACD;;AAEM,SAASC,MAAT,CAAmBD,MAAnB,EAAsD;AAC3D,SAAOA,MAAM,IAAI,IAAjB;AACD;;AASM,SAASE,cAAT,CAA2BF,MAA3B,EAA8C;AACnD,SAAOD,MAAM,CAACC,MAAD,CAAN,GAAkB,QAAO,OAAOA,MAAO,GAAvC,GAA4C,MAAnD;AACD;;AASM,SAASG,WAAT,CAAwBH,MAAxB,EAA4D;AACjE,SAAOD,MAAM,CAACC,MAAD,CAAN,GAAiB,MAAjB,GAA0B,MAAjC;AACD;;AAsBM,SAASI,SAAT,CACLJ,MADK,EAELK,GAFK,EASU;AACf,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B,WAAON,MAAM,CAACC,MAAD,CAAN,GACHK,GAAG,CAACL,MAAD,CADA,GAGH,IAHJ;AAID;;AAED,MAAI,OAAOK,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAM,IAAIC,KAAJ,CACH,+DAA8D,OAAOD,GAAI,EADtE,CAAN;AAGD;;AAED,QAAME,UAAU,GAAGF,GAAG,CAACF,WAAW,CAACH,MAAD,CAAZ,CAAtB;;AACA,MAAI,CAACO,UAAL,EAAiB;AACf,UAAM,IAAID,KAAJ,CACH,kCAAiCJ,cAAc,CAACF,MAAD,CAAS,OADrD,CAAN;AAGD;;AACD,SAAOD,MAAM,CAACC,MAAD,CAAN,GACH,qBAAWO,UAAX,EAAuBP,MAAvB,CADG,GAEH,qBAAWO,UAAX,CAFJ;AAGD","sourcesContent":["// Type-first utilities to handle optional values\n\nimport { mapToValue } from './map';\n\nexport type None = null | undefined;\nexport type Some<T> = Exclude<T, None>;\nexport type Option<T> = Some<T> | None;\n\nexport function isSome<T>(option: Option<T>): option is Some<T> {\n  return option != null;\n}\n\nexport function isNone<T>(option: Option<T>): option is None {\n  return option == null;\n}\n\n/**\n * Populate typename of `Option<T>`\n *\n * @param option\n *\n * @return Given `Option<string>`, returns `\"Some(string)\"` or `\"None\"`\n */\nexport function optionToString<T>(option: Option<T>) {\n  return isSome(option) ? `Some(${typeof option})` : 'None';\n}\n\n/**\n * Match the given option\n *\n * @param option\n *\n * @return `'some' | 'none'`\n */\nexport function matchOption<T>(option: Option<T>): 'some' | 'none' {\n  return isSome(option) ? 'some' : 'none';\n}\n\n/**\n * Subtype mapper for optional value.\n *\n * @param option\n * @param map A Function to map some, or an object to map both some and none.\n *\n * @example\n * ```ts\n * let args: Option<Array<string>>;\n *\n * // Expect: Option<string>\n * const optionalArgString = mapOption(args, args => args.join(' '));\n *\n * // Expect: string\n * const argString = mapOption(args, {\n *   some: args => args.join(' '),\n *   none: '', // default value\n * });\n * ```\n */\nexport function mapOption<T, RSome, RNone = None>(\n  option: Option<T>,\n  map: (\n    | ((t: Some<T>) => RSome)\n    | ({\n      some: RSome | ((t: Some<T>) => RSome),\n      none: RNone | (() => RNone),\n    })\n  ),\n): RSome | RNone {\n  if (typeof map === 'function') {\n    return isSome(option)\n      ? map(option)\n      // Only None value can be here.\n      : null as unknown as RNone;\n  }\n\n  if (typeof map !== 'object') {\n    throw new Error(\n      `The second argument only allows function or object but got: ${typeof map}`,\n    );\n  }\n\n  const matchedMap = map[matchOption(option)];\n  if (!matchedMap) {\n    throw new Error(\n      `The object doesn't have map to ${optionToString(option)} type`,\n    );\n  }\n  return isSome(option)\n    ? mapToValue(matchedMap, option)\n    : mapToValue(matchedMap);\n}\n"],"file":"option.js"}