import type { Wrap, Unwrap, BoxType } from './common';
export declare type TupleHead<TTuple extends readonly any[]> = (TTuple['length'] extends 0 ? never : TTuple[0]);
export declare type TupleTail<TTuple extends readonly any[]> = (((...tail: TTuple) => any) extends ((head: any, ...tail: infer TTail) => any) ? TTail : never);
declare namespace $Experimental {
    type TupleHead<Tuple extends readonly unknown[]> = Tuple extends [infer Head, ...infer _] ? Head : never;
    type TupleTail<Tuple extends readonly unknown[]> = Tuple extends [any?, ...infer Tail] ? Tail : never;
}
export declare type TupleAppend<TTuple extends readonly any[], TItem> = [TItem, ...TTuple];
export declare type TuplePrepend<TTuple extends readonly any[], TItem> = [...TTuple, TItem];
export declare type TupleMapPromise<Tuple extends readonly any[], Result extends readonly any[] = []> = {
    0: Result;
    1: TupleMapPromise<TupleTail<Tuple>, TupleAppend<Result, Promise<$Experimental.TupleHead<Tuple>>>>;
}[Tuple['length'] extends 0 ? 0 : 1];
export declare type TupleMapReturnType<Tuple extends readonly any[], Result extends readonly any[] = []> = {
    0: Result;
    1: TupleMapReturnType<$Experimental.TupleTail<Tuple>, TupleAppend<Result, ReturnType<TupleHead<Tuple>>>>;
}[Tuple['length'] extends 0 ? 0 : 1];
export declare type TupleMapPick<Tuple extends readonly any[], Key extends string, Result extends readonly any[] = []> = {
    0: Result;
    1: TupleMapPick<$Experimental.TupleTail<Tuple>, Key, TupleAppend<Result, Pick<TupleHead<Tuple>, Key>>>;
}[Tuple['length'] extends 0 ? 0 : 1];
export declare type TupleMapUnwrap<Tuple extends readonly any[], Result extends readonly any[] = []> = {
    0: Result;
    1: TupleMapUnwrap<$Experimental.TupleTail<Tuple>, TupleAppend<Result, Unwrap<$Experimental.TupleHead<Tuple>>>>;
}[Tuple['length'] extends 0 ? 0 : 1];
export declare type TupleMapWrap<Tuple extends readonly any[], Box extends BoxType<any>, Result extends readonly any[] = []> = {
    0: Result;
    1: TupleMapWrap<$Experimental.TupleTail<Tuple>, Box, TupleAppend<Result, Wrap<$Experimental.TupleHead<Tuple>, Box>>>;
}[Tuple['length'] extends 0 ? 0 : 1];
export declare type MakeTuple<T, N extends number, Result extends readonly T[] = []> = {
    0: Result;
    1: MakeTuple<T, N, [T, ...Result]>;
}[Result['length'] extends N ? 0 : 1];
export declare type TupleReplace<Tuple extends readonly any[], T, Result extends readonly T[] = []> = {
    0: Result;
    1: TupleReplace<$Experimental.TupleTail<Tuple>, T, [T, ...Result]>;
}[Tuple['length'] extends 0 ? 0 : 1];
export {};
