{"version":3,"file":"index.umd.js","sources":["../src/map.ts","../src/option.ts","../src/condition.ts"],"sourcesContent":["import type { Callable } from './common';\n\n// Force-infer mapped return type of callable properties\nexport type MapReturnType<TMap extends object> = (\n  keyof TMap extends infer TKey\n  ? TKey extends NonNullable<keyof TMap>\n  ? TMap[TKey] extends infer TMatch\n  ? TMatch extends Callable\n  ? ReturnType<TMatch>\n  : TMatch // Use as-is if it's not a callable\n  : never\n  : never\n  : never\n);\n\n/**\n * Map function to value or just value.\n */\ntype MapFunction<TValue, TArg> = (\n  | TValue\n  | ((arg: TArg) => TValue)\n);\n\n/**\n * Call map function to value or just value.\n *\n * @param map A map function to value or just value.\n * @param arg A argument to pass to map function.\\\n * It will be dropped if map is not a function.\n */\nexport function mapToValue<TValue, TArg>(map: MapFunction<TValue, TArg>, arg?: TArg): TValue {\n  if (typeof map === 'function') {\n    return (map as Callable)(arg);\n  }\n  return map;\n}\n","// Type-first utilities to handle optional values\n\nimport { mapToValue } from './map';\n\nexport type None = null | undefined;\nexport type Some<T> = Exclude<T, None>;\nexport type Option<T> = Some<T> | None;\n\nexport function isSome<T>(option: Option<T>): option is Some<T> {\n  return option != null;\n}\n\nexport function isNone<T>(option: Option<T>): option is None {\n  return option == null;\n}\n\n/**\n * Populate typename of `Option<T>`\n *\n * @param option\n *\n * @return Given `Option<string>`, returns `\"Some(string)\"` or `\"None\"`\n */\nexport function optionToString<T>(option: Option<T>) {\n  return isSome(option) ? `Some(${typeof option})` : 'None';\n}\n\n/**\n * Match the given option\n *\n * @param option\n *\n * @return `'some' | 'none'`\n */\nexport function matchOption<T>(option: Option<T>): 'some' | 'none' {\n  return isSome(option) ? 'some' : 'none';\n}\n\n/**\n * Subtype mapper for optional value.\n *\n * @param option\n * @param map A Function to map some, or an object to map both some and none.\n *\n * @example\n * ```ts\n * let args: Option<Array<string>>;\n *\n * // Expect: Option<string>\n * const optionalArgString = mapOption(args, args => args.join(' '));\n *\n * // Expect: string\n * const argString = mapOption(args, {\n *   some: args => args.join(' '),\n *   none: '', // default value\n * });\n * ```\n */\nexport function mapOption<T, RSome, RNone = None>(\n  option: Option<T>,\n  map: (\n    | ((t: Some<T>) => RSome)\n    | ({\n      some: RSome | ((t: Some<T>) => RSome),\n      none: RNone | (() => RNone),\n    })\n  ),\n): RSome | RNone {\n  if (typeof map === 'function') {\n    return isSome(option)\n      ? map(option)\n      // Only None value can be here.\n      : null as unknown as RNone;\n  }\n\n  if (typeof map !== 'object') {\n    throw new Error(\n      `The second argument only allows function or object but got: ${typeof map}`,\n    );\n  }\n\n  const matchedMap = map[matchOption(option)];\n  if (!matchedMap) {\n    throw new Error(\n      `The object doesn't have map to ${optionToString(option)} type`,\n    );\n  }\n  return isSome(option)\n    ? mapToValue(matchedMap, option)\n    : mapToValue(matchedMap);\n}\n","import type { InferrableAny } from './common';\n\nexport type Falsy = (\n  | false\n  | null\n  | undefined\n  | 0\n);\n\nexport type Truthy<T = InferrableAny> = Exclude<T, Falsy>;\n\nexport type Condition<T> = Truthy<T> | Falsy;\n\nexport function isTruthy<T>(condition: Condition<T>): condition is Truthy<T> {\n  return Boolean(condition);\n}\n\nexport function isFalsy<T>(condition: Condition<T>): condition is Falsy {\n  return !Boolean(condition);\n}\n"],"names":["mapToValue","map","arg","isSome","option","isNone","optionToString","matchOption","mapOption","Error","matchedMap","isTruthy","condition","Boolean","isFalsy"],"mappings":";;;;;;;;;;;;;;;;;;;;;;EA8BO,SAASA,UAAT,CAAkCC,GAAlC,EAAkEC,GAAlE,EAAsF;EAC3F,MAAI,OAAOD,GAAP,KAAe,UAAnB,EAA+B;EAC7B,WAAQA,GAAD,CAAkBC,GAAlB,CAAP;EACD;;EACD,SAAOD,GAAP;EACD;;EC3BM,SAASE,MAAT,CAAmBC,MAAnB,EAAyD;EAC9D,SAAOA,MAAM,IAAI,IAAjB;EACD;EAEM,SAASC,MAAT,CAAmBD,MAAnB,EAAsD;EAC3D,SAAOA,MAAM,IAAI,IAAjB;EACD;EASM,SAASE,cAAT,CAA2BF,MAA3B,EAA8C;EACnD,SAAOD,MAAM,CAACC,MAAD,CAAN,0BAAgCA,MAAhC,UAA4C,MAAnD;EACD;EASM,SAASG,WAAT,CAAwBH,MAAxB,EAA4D;EACjE,SAAOD,MAAM,CAACC,MAAD,CAAN,GAAiB,MAAjB,GAA0B,MAAjC;EACD;EAsBM,SAASI,SAAT,CACLJ,MADK,EAELH,GAFK,EASU;EACf,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;EAC7B,WAAOE,MAAM,CAACC,MAAD,CAAN,GACHH,GAAG,CAACG,MAAD,CADA,GAGH,IAHJ;EAID;;EAED,MAAI,QAAOH,GAAP,MAAe,QAAnB,EAA6B;EAC3B,UAAM,IAAIQ,KAAJ,+EACkER,GADlE,GAAN;EAGD;;EAED,MAAMS,UAAU,GAAGT,GAAG,CAACM,WAAW,CAACH,MAAD,CAAZ,CAAtB;;EACA,MAAI,CAACM,UAAL,EAAiB;EACf,UAAM,IAAID,KAAJ,0CAC8BH,cAAc,CAACF,MAAD,CAD5C,WAAN;EAGD;;EACD,SAAOD,MAAM,CAACC,MAAD,CAAN,GACHJ,UAAU,CAACU,UAAD,EAAaN,MAAb,CADP,GAEHJ,UAAU,CAACU,UAAD,CAFd;EAGD;;EC7EM,SAASC,QAAT,CAAqBC,SAArB,EAAsE;EAC3E,SAAOC,OAAO,CAACD,SAAD,CAAd;EACD;EAEM,SAASE,OAAT,CAAoBF,SAApB,EAAiE;EACtE,SAAO,CAACC,OAAO,CAACD,SAAD,CAAf;EACD;;;;;;;;;;;;;;;;;;;"}