"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.onPostBootstrap = exports.onPreBootstrap = void 0;

var _path = _interopRequireDefault(require("path"));

var _commonTags = require("common-tags");

var _utils = require("@graphql-tools/utils");

var _graphqlTagPluck = require("@graphql-tools/graphql-tag-pluck");

var _common = require("./common");

var _workers = require("./workers");

var _pluginUtils = require("./plugin-utils");

// Plugin will track documents what is actually used by Gatsby.
const trackedSource = new Map();
let pluginOptions;
let unsubscribeQueryExtraction;

const onPreBootstrap = ({
  store: _store,
  reporter
}, options) => {
  const store = _store; // Validate plugin options earlier.

  pluginOptions = (0, _pluginUtils.requirePluginOptions)(options, {
    store,
    reporter
  });
  reporter.verbose('[typegen] Successfully validate your configuration.\n' + JSON.stringify(pluginOptions, null, 2));
  reporter.verbose('[typegen] Listen on query extraction'); // eslint-disable-next-line @typescript-eslint/no-misused-promises

  unsubscribeQueryExtraction = store.subscribe(async () => {
    const {
      lastAction
    } = store.getState();

    if (lastAction.type !== 'QUERY_EXTRACTION_BABEL_SUCCESS') {
      return;
    }

    const {
      componentPath
    } = lastAction.payload;

    if (trackedSource.has(componentPath)) {
      return;
    }

    try {
      const code = await (0, _common.readFile)(componentPath);
      const extractedSDL = await (0, _graphqlTagPluck.gqlPluckFromCodeString)(componentPath, code, _pluginUtils.GRAPHQL_TAG_PLUCK_OPTIONS);

      if (extractedSDL) {
        const document = (0, _utils.parseGraphQLSDL)(componentPath, extractedSDL, {
          noLocation: true
        });
        trackedSource.set(componentPath, document);
      }
    } catch (error) {
      reporter.error(`[typegen] Fail to extract GraphQL documents from ${componentPath}`, error);
    }
  });
};

exports.onPreBootstrap = onPreBootstrap;

const onPostBootstrap = async ({
  store: _store,
  reporter
}) => {
  const store = _store;
  const {
    language,
    namespace,
    outputPath,
    includeResolvers,
    emitSchema,
    emitPluginDocuments,
    autoFix,
    scalars
  } = pluginOptions;
  reporter.verbose('[typegen] End-up listening on query extraction.');
  unsubscribeQueryExtraction();
  const state = store.getState();
  const basePath = state.program.directory;
  const pluginState = {
    schema: state.schema
  };
  const emitSchemaEntries = Object.entries(emitSchema);
  const emitSchemaWorker = emitSchemaEntries.length > 0 && (0, _workers.setupEmitSchemaWorker)({
    reporter
  });

  const pushEmitSchemaTask = () => {
    if (!emitSchemaWorker) {
      return;
    }

    void emitSchemaWorker.push({
      schema: pluginState.schema,
      entries: emitSchemaEntries
    });
  };

  const codegenWorker = (0, _workers.setupCodegenWorker)({
    language,
    namespace,
    outputPath,
    includeResolvers,
    reporter,
    scalarMap: scalars
  });

  const pushCodegenTask = () => {
    void codegenWorker.push({
      schema: pluginState.schema,
      documents: (0, _common.deduplicateFragmentFromDocuments)([...trackedSource.values()].filter(Boolean))
    });
  };

  const insertTypeWorker = autoFix && (0, _workers.setupInsertTypeWorker)({
    language,
    namespace,
    reporter
  });

  const pushInsertTypeTask = async componentPath => {
    if (!insertTypeWorker) {
      return;
    }

    if (language === 'typescript' && /\.tsx?$/.test(componentPath)) {
      void insertTypeWorker.push({
        file: componentPath
      });
    } // Flow version is bit more slower because should check the `` comment exist.


    if (language === 'flow' && /\.jsx?$/.test(componentPath)) {
      const content = await (0, _common.readFile)(componentPath);
      const hasFlowComment = content.includes('@flow');
      reporter.verbose(`[typegen] Check if the file has flow comment: ${hasFlowComment.toString()}`);

      if (hasFlowComment) {
        void insertTypeWorker.push({
          file: componentPath
        });
      }
    }
  }; // Task 1. Emit schema


  pushEmitSchemaTask(); // Task 2. Emit plugin documents
  // FIXME: Move this to a seperated service like others.
  // (not necessarily for now becuase this is one-time job)
  //
  // Gatsby component paths have forward slashes.
  // The following filter doesn't work properly on Windows if the matched path uses backslashes

  const srcPath = _path.default.resolve(basePath, 'src').replace(/\\/g, '/');

  const pluginDocuments = Object.values(emitPluginDocuments).some(Boolean) && (0, _commonTags.stripIndent)(Array.from(trackedSource.entries()).filter(([componentPath]) => !componentPath.startsWith(srcPath)).map(([, source]) => source.rawSDL).join('\n'));

  if (pluginDocuments) {
    for (const [documentOutputPath, documentOutputOptions] of Object.entries(emitPluginDocuments)) {
      if (!documentOutputOptions) continue;
      reporter.verbose(`[typegen] Emit Gatsby plugin documents into ${documentOutputPath}`);
      await (0, _common.writeFile)(_path.default.resolve(basePath, documentOutputPath), pluginDocuments);
    }
  } // Task 3. Codegen


  pushCodegenTask(); // Task 4. Auto-fixing!

  for (const componentPath of trackedSource.keys()) {
    void pushInsertTypeTask(componentPath);
  } // Subscribe GatsbyJS store and handle changes in development mode


  if (process.env.NODE_ENV === 'development') {
    reporter.verbose('[typegen] Watching schema/query changes and re-run workers');
    store.subscribe(() => {
      const state = store.getState();
      const lastAction = state.lastAction; // Listen gatsby actions
      // - QUERY_EXTRACTION_BABEL_SUCCESS action for pre-exisitng static queries.
      // - SET_SCHEMA action for schema changing.
      // - QUERY_EXTRACTED action for page queries.
      // - REPLACE_STATIC_QUERY action for static queries.

      if (lastAction.type === 'QUERY_EXTRACTION_BABEL_SUCCESS') {
        const {
          componentPath
        } = lastAction.payload;

        if (trackedSource.has(componentPath)) {
          // If the component already tracked, other actions will handle the generating
          return;
        }

        void (async () => {
          try {
            const code = await (0, _common.readFile)(componentPath);
            const extractedSDL = await (0, _graphqlTagPluck.gqlPluckFromCodeString)(componentPath, code, _pluginUtils.GRAPHQL_TAG_PLUCK_OPTIONS);

            if (extractedSDL) {
              const document = (0, _utils.parseGraphQLSDL)(componentPath, extractedSDL, {
                noLocation: true
              });
              trackedSource.set(componentPath, document);
              pushCodegenTask();
              void pushInsertTypeTask(componentPath);
            }
          } catch (error) {
            reporter.error(`[typegen] Fail to extract GraphQL documents from ${componentPath}`, error);
          }
        })();
      }

      if (lastAction.type === 'SET_SCHEMA') {
        pluginState.schema = state.schema;
        pushEmitSchemaTask();
        pushCodegenTask();
      }

      if (lastAction.type === 'QUERY_EXTRACTED' || lastAction.type === 'REPLACE_STATIC_QUERY') {
        const {
          payload: {
            query,
            componentPath
          }
        } = lastAction;
        const source = trackedSource.get(componentPath);

        if ((source === null || source === void 0 ? void 0 : source.rawSDL) === query) {
          return;
        }

        const document = (0, _utils.parseGraphQLSDL)(componentPath, query, {
          noLocation: true
        });
        trackedSource.set(componentPath, document);
        pushCodegenTask();
        void pushInsertTypeTask(componentPath);
      }
    });
  }
};

exports.onPostBootstrap = onPostBootstrap;