"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.setupInsertTypeWorker = void 0;

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _async = require("async");

var _common = require("../common");

function _wrapRegExp(re, groups) { _wrapRegExp = function (re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = (0, _wrapNativeSuper2.default)(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } (0, _inherits2.default)(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (typeof args[args.length - 1] !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

const CONCURRENCY = 4;
/**
 * (?<CallExpressionName>useStaticQuery
 *   (?<TypeTemplate><
 *     (?<TypeArgument>\S*)
 *   >)?
 * )
 * \([\s\S]*?
 * graphql
 * (?<TemplateLiteral>`\s*?
 *   (?<QueryDefinitionStart>query
 *     (?<QueryName>\S*)
 *     [^{]?\{
 *   )
 *   [^`]*?
 * `)
 */

const STATIC_QUERY_HOOK_REGEXP = _wrapRegExp(/(useStaticQuery(<(\S*)>)?)\([\s\S]*?graphql(`\s*?(query (\S*)[^{]{)[^`]*?`)/g, {
  CallExpressionName: 1,
  TypeTemplate: 2,
  TypeArgument: 3,
  TemplateLiteral: 4,
  QueryDefinitionStart: 5,
  QueryName: 6
});
/**
 * (?<JsxTagOpening><StaticQuery
 *   (?<TagTypeTemplate><
 *     (?<TagTypeArgument>\S+)
 *   >)?
 * )
 * [\s\S]+?
 * query={
 * [\s\S]*?
 * graphql
 * (?<TemplateLiteral>`\s*?
 *   (?<QueryDefinitionStart>query
 *     (?<QueryName>\S*)
 *     [^{]?\{
 *   )
 *   [^`]*?
 * `)
 */


const STATIC_QUERY_COMPONENT_REGEXP = _wrapRegExp(/(<StaticQuery(<(\S+)>)?)[\s\S]+?query={[\s\S]*?graphql(`\s*?(query (\S*)[^{]?\{)[^`]*`)/g, {
  JsxTagOpening: 1,
  TagTypeTemplate: 2,
  TagTypeArgument: 3,
  TemplateLiteral: 4,
  QueryDefinitionStart: 5,
  QueryName: 6
});

const setupInsertTypeWorker = ({
  reporter,
  language,
  namespace
}) => {
  const worker = (0, _async.queue)((0, _async.asyncify)(async task => {
    const {
      file
    } = task;
    const accessor = language === 'typescript' ? '.' : '$';
    const content = await (0, _common.readFile)(file);
    const fixed = content // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .replace(STATIC_QUERY_HOOK_REGEXP, (substring, ...args) => {
      const {
        length: l,
        [l - 1]: groups
      } = args; // eslint-disable-next-line

      return substring.replace(groups['CallExpressionName'], `useStaticQuery<${namespace}${accessor}${groups['QueryName']}Query>`);
    }) // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .replace(STATIC_QUERY_COMPONENT_REGEXP, (substring, ...args) => {
      const {
        length: l,
        [l - 1]: groups
      } = args; // eslint-disable-next-line

      return substring.replace(groups['JsxTagOpening'], `<StaticQuery<${namespace}${accessor}${groups['QueryName']}Query>`);
    });

    if (content !== fixed) {
      reporter.verbose(`[typegen] Insert type definitions into ${file}\nbecause documents were changed.`);
      await (0, _common.writeFile)(file, fixed);
    }
  }), CONCURRENCY);
  return worker;
};

exports.setupInsertTypeWorker = setupInsertTypeWorker;