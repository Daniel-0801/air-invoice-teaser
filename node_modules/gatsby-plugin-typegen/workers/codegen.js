"use strict";

exports.__esModule = true;
exports.setupCodegenWorker = void 0;

var _async = require("async");

var _core = require("@graphql-codegen/core");

var _common = require("../common");

// no exposed types
// import type { FlowResolversPluginConfig } from '@graphql-codegen/flow-resolvers/config';
const CARGO_DELAY = 1000; // Preset configurations to ensure compatibility with Gatsby.

const DEFAULT_SHARED_CONFIG = {
  namingConvention: {
    typeNames: 'keep',
    enumValues: 'keep',
    transformUnderscore: false
  },
  addUnderscoreToArgsType: true,
  skipTypename: true,
  scalars: {
    // A date string, such as 2007-12-03, compliant with the ISO 8601 standard for
    // representation of dates and times using the Gregorian calendar.
    Date: 'string',
    // The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
    // Note: This will never be used since this is reserved by GatsbyJS internal
    JSON: 'never'
  }
};
const DEFAULT_TYPESCRIPT_CONFIG = {
  avoidOptionals: true,
  immutableTypes: true,
  maybeValue: 'T | undefined',
  noExport: true,
  enumsAsTypes: true
};
const DEFAULT_TYPESCRIPT_OPERATIONS_CONFIG = { ...DEFAULT_TYPESCRIPT_CONFIG,
  exportFragmentSpreadSubTypes: true
};
const DEFAULT_TYPESCRIPT_RESOLVERS_CONFIG = {
  // See https://github.com/dotansimha/graphql-code-generator/pull/5458
  // ...DEFAULT_TYPESCRIPT_CONFIG,
  contextType: 'gatsby-plugin-typegen/types#GatsbyResolverContext'
};
const DEFAULT_FLOW_CONFIG = {
  useFlowExactObjects: true,
  useFlowReadOnlyTypes: true
};
const DEFAULT_FLOW_OPERATIONS_CONFIG = { ...DEFAULT_FLOW_CONFIG,
  exportFragmentSpreadSubTypes: true
};
const DEFAULT_FLOW_RESOLVERS_CONFIG = { ...DEFAULT_FLOW_CONFIG // FIXME: add config for contextType

};

const setupCodegenWorker = ({
  outputPath,
  language,
  namespace,
  includeResolvers,
  scalarMap,
  reporter
}) => {
  const worker = (0, _async.cargo)((0, _async.asyncify)(async tasks => {
    const {
      length: l,
      [l - 1]: last
    } = tasks;
    const {
      schema: schemaAst,
      documents
    } = last;
    const codegenOptions = {
      // eslint-disable-next-line
      schema: undefined,
      schemaAst,
      documents,
      filename: outputPath,
      config: { ...DEFAULT_SHARED_CONFIG,
        scalars: { ...DEFAULT_SHARED_CONFIG.scalars,
          ...scalarMap
        }
      },
      plugins: [],
      pluginMap: {}
    };

    if (language === 'typescript') {
      codegenOptions.plugins.push({
        typescript: DEFAULT_TYPESCRIPT_CONFIG
      });
      codegenOptions.pluginMap['typescript'] = require('@graphql-codegen/typescript');
      codegenOptions.plugins.push({
        typescriptOperations: DEFAULT_TYPESCRIPT_OPERATIONS_CONFIG
      });
      codegenOptions.pluginMap['typescriptOperations'] = require('@graphql-codegen/typescript-operations');

      if (includeResolvers) {
        codegenOptions.plugins.push({
          typescriptResolvers: DEFAULT_TYPESCRIPT_RESOLVERS_CONFIG
        });
        codegenOptions.pluginMap['typescriptResolvers'] = require('@graphql-codegen/typescript-resolvers');
      }
    } else
      /* flow */
      {
        const flow = { ...DEFAULT_FLOW_CONFIG,
          typesPrefix: `${namespace}$`
        };
        codegenOptions.plugins.push({
          flow
        });
        codegenOptions.pluginMap['flow'] = require('@graphql-codegen/flow');
        const flowOperations = { ...DEFAULT_FLOW_OPERATIONS_CONFIG,
          typesPrefix: `${namespace}$`
        };
        codegenOptions.plugins.push({
          flowOperations
        });
        codegenOptions.pluginMap['flowOperations'] = require('@graphql-codegen/flow-operations');

        if (includeResolvers) {
          const flowResolvers = { ...DEFAULT_FLOW_RESOLVERS_CONFIG,
            typesPrefix: `${namespace}$`
          };
          codegenOptions.plugins.push({
            flowResolvers
          });
          codegenOptions.pluginMap['flowResolvers'] = require('@graphql-codegen/flow-resolvers');
        }
      }

    reporter.verbose(`[typegen] Generate type definitions to ${outputPath}. (language: ${(0, _common.formatLanguage)(language)})`);

    try {
      let result = await (0, _core.codegen)(codegenOptions);

      if (language === 'typescript') {
        result = `declare namespace ${namespace} {\n${result}\n}`;
      } else
        /* flow */
        {
          const FLOW_FILE_TOP = '/* @flow */\n\n';
          const FLOW_FILE_TOP_REGEXP = /\/\*\s*@flow\s*\*\/\s*/;
          result = result.replace(FLOW_FILE_TOP_REGEXP, FLOW_FILE_TOP + 'opaque type never = mixed;\n\n');
          const TYPEDEF_EXPORT_NODE_REGEXP = /export type ((.*)(\{\|?|;)($|\s))/g;
          result = result.replace(TYPEDEF_EXPORT_NODE_REGEXP, 'declare type $1');
        }

      result = '/* eslint-disable */\n\n' + result;
      await (0, _common.writeFile)(outputPath, result);
    } catch (e) {
      reporter.panicOnBuild('[typegen] An error on codegen', e);
    }

    return (0, _common.delay)(CARGO_DELAY);
  }));
  return worker;
};

exports.setupCodegenWorker = setupCodegenWorker;