"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.deduplicateFragmentFromDocuments = deduplicateFragmentFromDocuments;
exports.formatLanguage = exports.delay = exports.writeFile = exports.readFile = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var _util = require("util");

const _mkdir = (0, _util.promisify)(_fs.default.mkdir);

const _readFile = (0, _util.promisify)(_fs.default.readFile);

const _writeFile = (0, _util.promisify)(_fs.default.writeFile);

const readFile = async path => _readFile(path, {
  encoding: 'utf-8'
});

exports.readFile = readFile;

const writeFile = async (path, data) => {
  await _mkdir((0, _path.dirname)(path), {
    recursive: true
  });
  await _writeFile(path, data, {
    encoding: 'utf-8'
  });
};

exports.writeFile = writeFile;

const delay = ms => new Promise(res => setTimeout(res, ms));

exports.delay = delay;

const formatLanguage = lang => lang === 'typescript' ? 'TypeScript' : 'Flow';

exports.formatLanguage = formatLanguage;

function deduplicateFragmentFromDocuments(documents) {
  const existFragmentNames = new Set();
  return documents.map(source => {
    const {
      document
    } = source; // Nothing to do for other sources

    if (!document) {
      return source;
    }

    const uniqDefinitions = document.definitions.filter(def => {
      // De-dup only cares about fragments
      if (def.kind !== 'FragmentDefinition') {
        return true;
      }

      const fragmentName = def.name.value;
      const duplicated = existFragmentNames.has(fragmentName);
      if (!duplicated) existFragmentNames.add(fragmentName);
      return !duplicated;
    });
    return { ...source,
      document: { ...document,
        definitions: uniqDefinitions
      }
    };
  });
}